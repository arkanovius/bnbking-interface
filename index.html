import { useEffect, useMemo, useState } from "react";
import { BrowserProvider, Contract, JsonRpcProvider, formatEther } from "ethers";

/** Contrat */
const CONTRACT_ADDRESS = "0x864EE1d1B51306e30836B84AdE81e39ebB6e8e0C";

/** BSC Mainnet */
const BSC_CHAIN_ID_DEC = 56;
const BSC_CHAIN_ID_HEX = "0x38";

/** RPC lecture (fallback si wallet pas connecté) */
const BSC_RPC = "https://bsc-dataseed.bnbchain.org";

/** ABI minimal (getKingdom + actions write) */
const ABI = [
  {
    inputs: [{ internalType: "address", name: "_player", type: "address" }],
    name: "getKingdom",
    outputs: [
      {
        components: [
          { internalType: "uint32", name: "gold", type: "uint32" },
          { internalType: "uint32", name: "gems", type: "uint32" },
          { internalType: "uint32", name: "perHour", type: "uint32" },
          { internalType: "uint32", name: "alliesCount", type: "uint32" },
          { internalType: "uint32", name: "alliesEarned", type: "uint32" },
          { internalType: "uint32", name: "claimTime", type: "uint32" },
          { internalType: "uint32", name: "battleTime", type: "uint32" },
          { internalType: "uint16", name: "battleId", type: "uint16" },
          { internalType: "uint8", name: "battlesInRow", type: "uint8" },
          { internalType: "bool", name: "isWinInRow", type: "bool" },
          { internalType: "address", name: "ally", type: "address" },
          { internalType: "uint8[360]", name: "tiles", type: "uint8[360]" }
        ],
        internalType: "struct Kingdom",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint8", name: "_winChance", type: "uint8" }],
    name: "battle",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "_gems", type: "uint256" }],
    name: "sellGems",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint16[]", name: "_tileIds", type: "uint16[]" },
      { internalType: "uint8", name: "_level", type: "uint8" }
    ],
    name: "placeBuildings",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint16", name: "_tileId", type: "uint16" }],
    name: "upgradeBuilding",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// Stats bâtiments (copie locale du contrat pour UI)
function buildingStats(level: number) {
  const map: Record<number, { cost: number; perHour: number }> = {
    1: { cost: 10000, perHour: 8 },
    2: { cost: 28000, perHour: 24 },
    3: { cost: 54000, perHour: 48 },
    4: { cost: 100000, perHour: 96 },
    5: { cost: 250000, perHour: 248 },
    6: { cost: 500000, perHour: 520 },
    7: { cost: 1000000, perHour: 1100 },
    8: { cost: 2000000, perHour: 2300 }
  };
  return map[level] || null;
}

function decodeTile(tileValue: number) {
  if (tileValue === 0) return { empty: true, level: 0, upgrades: 0, raw: 0 };
  const level = tileValue % 10; // 1..8
  const upgrades = Math.floor(tileValue / 10); // 0..9
  return { empty: false, level, upgrades, raw: tileValue };
}

function shortAddr(a: string) {
  if (!a) return "";
  return `${a.slice(0, 6)}…${a.slice(-4)}`;
}

function tilesToGrid(tiles360: number[]) {
  const rows = 18;
  const cols = 20;
  const grid: number[][] = [];
  for (let r = 0; r < rows; r++) {
    const row: number[] = [];
    for (let c = 0; c < cols; c++) {
      row.push(tiles360[r * cols + c]);
    }
    grid.push(row);
  }
  return grid;
}

function tileBg(level: number) {
  const palette = ["#111827", "#0ea5e9", "#22c55e", "#a3e635", "#f59e0b", "#f97316", "#ef4444", "#a855f7", "#f5f5f5"];
  return palette[Math.min(Math.max(level, 0), palette.length - 1)];
}

export default function App() {
  const readProvider = useMemo(() => new JsonRpcProvider(BSC_RPC), []);
  const readContract = useMemo(() => new Contract(CONTRACT_ADDRESS, ABI, readProvider), [readProvider]);

  const [walletProvider, setWalletProvider] = useState<BrowserProvider | null>(null);
  const [signer, setSigner] = useState<any>(null);
  const [account, setAccount] = useState("");
  const [chainOk, setChainOk] = useState(false);

  const [kingdom, setKingdom] = useState<any>(null);
  const [contractBnb, setContractBnb] = useState("");

  const [sellAmount, setSellAmount] = useState("");

  const [winChance, setWinChance] = useState(50); // 40..60
  const [nowTs, setNowTs] = useState(Math.floor(Date.now() / 1000));

  // Build/Upgrade UI state
  const [mode, setMode] = useState<"build" | "upgrade">("build");
  const [buildLevel, setBuildLevel] = useState(1);
  const [selectedBuildTiles, setSelectedBuildTiles] = useState(new Set<number>());
  const [selectedUpgradeTile, setSelectedUpgradeTile] = useState<number | null>(null);

  const [status, setStatus] = useState("");
  const [err, setErr] = useState("");

  const writeContract = useMemo(() => {
    if (!signer) return null;
    return new Contract(CONTRACT_ADDRESS, ABI, signer);
  }, [signer]);

  async function refreshContractBalance() {
    try {
      const bal = await readProvider.getBalance(CONTRACT_ADDRESS);
      setContractBnb(formatEther(bal));
    } catch {}
  }

  async function loadKingdom(addr: string) {
    setErr("");
    setStatus("Chargement du Kingdom…");
    try {
      const k = await readContract.getKingdom(addr);
      const tiles = Array.from(k.tiles).map((x: any) => Number(x));

      setKingdom({
        gold: Number(k.gold),
        gems: Number(k.gems),
        perHour: Number(k.perHour),
        alliesCount: Number(k.alliesCount),
        alliesEarned: Number(k.alliesEarned),
        claimTime: Number(k.claimTime),
        battleTime: Number(k.battleTime),
        battleId: Number(k.battleId),
        battlesInRow: Number(k.battlesInRow),
        isWinInRow: Boolean(k.isWinInRow),
        ally: k.ally,
        tiles
      });

      setSelectedBuildTiles(new Set());
      setSelectedUpgradeTile(null);

      await refreshContractBalance();
      setStatus("");
    } catch (e: any) {
      setStatus("");
      setErr(e?.shortMessage || e?.message || String(e));
    }
  }

  useEffect(() => {
    if (!account) return;
    const id = setInterval(() => loadKingdom(account), 30000);
    return () => clearInterval(id);
  }, [account]);

  async function connectWallet() {
    setErr("");
    setStatus("");
    if (!window.ethereum) {
      setErr("MetaMask (window.ethereum) introuvable.");
      return;
    }
    try {
      const p = new BrowserProvider(window.ethereum);
      await p.send("eth_requestAccounts", []);
      const s = await p.getSigner();
      const addr = await s.getAddress();

      const net = await p.getNetwork();
      const ok = Number(net.chainId) === BSC_CHAIN_ID_DEC;

      setWalletProvider(p);
      setSigner(s);
      setAccount(addr);
      setChainOk(ok);

      if (!ok) {
        setStatus("Wallet connecté, mais pas sur BSC. Clique sur “Switch BSC”.");
      } else {
        setStatus("Wallet connecté.");
        await loadKingdom(addr);
      }
    } catch (e: any) {
      setErr(e?.shortMessage || e?.message || String(e));
    }
  }

  async function switchToBSC() {
    setErr("");
    if (!window.ethereum) return;
    try {
      await window.ethereum.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: BSC_CHAIN_ID_HEX }]
      });
      if (walletProvider) {
        const net = await walletProvider.getNetwork();
        const ok = Number(net.chainId) === BSC_CHAIN_ID_DEC;
        setChainOk(ok);
        if (ok && account) await loadKingdom(account);
      }
    } catch (e: any) {
      setErr(e?.message || String(e));
    }
  }

  async function sellGems() {
    setErr("");
    setStatus("");
    if (!writeContract) return setErr("Connecte ton wallet d’abord.");
    if (!chainOk) return setErr("Pas sur BSC Mainnet (chainId 56).");

    const n = Number(sellAmount);
    if (!Number.isFinite(n) || n <= 0) return setErr("Entre un nombre > 0.");

    try {
      setStatus("Envoi de sellGems… (signature MetaMask)");
      const tx = await writeContract.sellGems(BigInt(Math.floor(n)));
      setStatus(`Tx envoyée: ${tx.hash.slice(0, 10)}...`);
      await tx.wait();
      setStatus("Confirmé ✅ Rechargement…");
      await loadKingdom(account);
      setStatus("Terminé.");
    } catch (e: any) {
      setStatus("");
      setErr(e?.shortMessage || e?.message || String(e));
    }
  }

  async function doBattle() {
    setErr("");
    setStatus("");
    if (!writeContract) return setErr("Connecte ton wallet d’abord.");
    if (!chainOk) return setErr("Pas sur BSC Mainnet.");
    if (!kingdom) return setErr("Kingdom non chargé.");

    const wc = Number(winChance);
    if (!Number.isFinite(wc) || wc < 40 || wc > 60) return setErr("Win chance 40..60.");

    if (kingdom.perHour <= 0) return setErr("perHour = 0 → impossible.");
    if (battleRemaining > 0) return setErr(`Cooldown: ${formatDuration(battleRemaining)} restant.`);

    try {
      setStatus("Envoi de battle… (signature)");
      const tx = await writeContract.battle(wc);
      setStatus(`Tx: ${tx.hash.slice(0, 10)}...`);
      await tx.wait();
      setStatus("Confirmé ✅ Rechargement…");
      await loadKingdom(account);
      setStatus("Terminé.");
    } catch (e: any) {
      setStatus("");
      setErr(e?.shortMessage || e?.message || String(e));
    }
  }

  function onTileClick(tileId: number) {
    if (!kingdom) return;

    const t = decodeTile(kingdom.tiles[tileId]);

    if (mode === "build") {
      if (!t.empty) return;
      const next = new Set(selectedBuildTiles);
      if (next.has(tileId)) next.delete(tileId);
      else next.add(tileId);
      setSelectedBuildTiles(next);
      return;
    }

    // mode upgrade
    if (t.empty) return;
    if (t.level <= 0 || t.level >= 9) return;
    if (t.upgrades >= 9) return;
    setSelectedUpgradeTile(tileId);
  }

  async function placeBuildings() {
    setErr("");
    setStatus("");
    if (!writeContract) return setErr("Connecte ton wallet.");
    if (!chainOk) return setErr("Pas sur BSC.");
    if (!kingdom) return setErr("Kingdom non chargé.");
    if (selectedBuildTiles.size < 1) return setErr("Sélectionne au moins 1 case.");

    const lvl = Number(buildLevel);
    if (!(lvl >= 1 && lvl <= 8)) return setErr("Niveau 1..8.");

    const st = buildingStats(lvl);
    const count = selectedBuildTiles.size;
    const estCost = st ? st.cost * count : null;
    if (estCost !== null && kingdom.gold < estCost) {
      return setErr(`Gold insuffisant (estimation: ${estCost.toLocaleString()}).`);
    }

    try {
      setStatus("Envoi placeBuildings…");
      const tileIds = Array.from(selectedBuildTiles).sort((a, b) => a - b);
      const tx = await writeContract.placeBuildings(tileIds, lvl);
      setStatus(`Tx: ${tx.hash.slice(0, 10)}...`);
      await tx.wait();
      setStatus("Confirmé ✅");
      await loadKingdom(account);
      setStatus("Terminé.");
    } catch (e: any) {
      setStatus("");
      setErr(e?.shortMessage || e?.message || String(e));
    }
  }

  async function upgradeBuilding() {
    setErr("");
    setStatus("");
    if (!writeContract) return setErr("Connecte ton wallet.");
    if (!chainOk) return setErr("Pas sur BSC.");
    if (!kingdom) return setErr("Kingdom non chargé.");
    if (selectedUpgradeTile === null) return setErr("Sélectionne une case.");

    const t = decodeTile(kingdom.tiles[selectedUpgradeTile]);
    if (t.empty) return setErr("Case vide.");
    if (t.level <= 0 || t.level >= 9) return setErr("Non upgradeable.");
    if (t.upgrades >= 9) return setErr("Max upgrades.");

    const st = buildingStats(t.level);
    const estCost = st ? Math.floor(st.cost / 4) : null;
    if (estCost !== null && kingdom.gold < estCost) {
      return setErr(`Gold insuffisant (estimation: ${estCost.toLocaleString()}).`);
    }

    try {
      setStatus("Envoi upgradeBuilding…");
      const tx = await writeContract.upgradeBuilding(selectedUpgradeTile);
      setStatus(`Tx: ${tx.hash.slice(0, 10)}...`);
      await tx.wait();
      setStatus("Confirmé ✅");
      await loadKingdom(account);
      setStatus("Terminé.");
    } catch (e: any) {
      setStatus("");
      setErr(e?.shortMessage || e?.message || String(e));
    }
  }

  useEffect(() => {
    const id = setInterval(() => setNowTs(Math.floor(Date.now() / 1000)), 1000);
    return () => clearInterval(id);
  }, []);

  useEffect(() => {
    if (!window.ethereum) return;
    const onAccounts = (accs: string[]) => {
      const a = accs?.[0] || "";
      setAccount(a);
      if (a && chainOk) loadKingdom(a);
    };
    const onChain = () => connectWallet();
    window.ethereum.on("accountsChanged", onAccounts);
    window.ethereum.on("chainChanged", onChain);
    return () => {
      window.ethereum.removeListener("accountsChanged", onAccounts);
      window.ethereum.removeListener("chainChanged", onChain);
    };
  }, [chainOk]);

  const grid = kingdom?.tiles ? tilesToGrid(kingdom.tiles) : null;

  const battleCooldownSec = 86400;
  const lastBattle = kingdom?.battleTime ? Number(kingdom.battleTime) : 0;
  const nextBattleAt = lastBattle + battleCooldownSec;
  const battleRemaining = Math.max(0, nextBattleAt - nowTs);
  const battleReady = battleRemaining === 0;

  function formatDuration(s: number) {
    const hh = Math.floor(s / 3600);
    const mm = Math.floor((s % 3600) / 60);
    const ss = s % 60;
    return `${hh.toString().padStart(2, "0")}:${mm.toString().padStart(2, "0")}:${ss.toString().padStart(2, "0")}`;
  }

  const lvlStats = buildingStats(Number(buildLevel));
  const buildCount = selectedBuildTiles.size;
  const estBuildCost = lvlStats ? lvlStats.cost * buildCount : null;
  const estBuildPerHour = lvlStats ? lvlStats.perHour * buildCount : null;

  const upgradeTileInfo = kingdom && selectedUpgradeTile !== null ? decodeTile(kingdom.tiles[selectedUpgradeTile]) : null;
  const upgradeStats = upgradeTileInfo && !upgradeTileInfo.empty ? buildingStats(upgradeTileInfo.level) : null;
  const estUpgradeCost = upgradeStats ? Math.floor(upgradeStats.cost / 4) : null;
  const estUpgradePerHour = upgradeStats ? Math.floor(upgradeStats.perHour / 4) : null;

  return (
    <div style={{ maxWidth: 1180, margin: "36px auto", padding: 16, fontFamily: "system-ui" }}>
      <header style={{ display: "flex", justifyContent: "space-between", gap: 12, flexWrap: "wrap" }}>
        <div>
          <h1 style={{ margin: 0 }}>BNBKing — dApp (kingdom + sell + build + upgrade)</h1>
          <div style={{ opacity: 0.7, marginTop: 6 }}>
            Contract: <code>{CONTRACT_ADDRESS}</code>
          </div>
        </div>

        <div style={{ display: "flex", gap: 10, alignItems: "center" }}>
          {account ? (
            <div style={{ padding: "8px 10px", border: "1px solid #e5e7eb", borderRadius: 12 }}>
              <div style={{ fontSize: 12, opacity: 0.7 }}>Connecté</div>
              <div style={{ fontWeight: 650 }}>{shortAddr(account)}</div>
              <div style={{ fontSize: 12, marginTop: 2, color: chainOk ? "#16a34a" : "#ef4444" }}>
                {chainOk ? "BSC Mainnet" : "Mauvaise chaîne"}
              </div>
            </div>
          ) : (
            <div style={{ opacity: 0.7, fontSize: 13 }}>Wallet non connecté</div>
          )}

          <button onClick={connectWallet} style={btn}>
            {account ? "Re-connect" : "Connect wallet"}
          </button>
          <button onClick={switchToBSC} style={{ ...btn, background: "#111827" }}>
            Switch BSC
          </button>
        </div>
      </header>

      <div style={{ display: "grid", gridTemplateColumns: "440px 1fr", gap: 16, marginTop: 18 }}>
        {/* LEFT - Actions */}
        <section style={card}>
          <h2 style={h2}>Actions</h2>

          <div style={label}>Contract balance (BNB)</div>
          <div style={{ fontSize: 18, fontWeight: 700 }}>{contractBnb || "—"}</div>

          <hr style={hr} />

          <div style={label}>Lire mon Kingdom</div>
          <button style={btn} disabled={!account} onClick={() => account && loadKingdom(account)}>
            Refresh Kingdom
          </button>

          <hr style={hr} />

          <div style={label}>Vendre des gemmes → BNB</div>
          <input
            style={input}
            placeholder="ex: 1000"
            value={sellAmount}
            onChange={(e) => setSellAmount(e.target.value)}
          />
          <button style={{ ...btn, background: "#0ea5e9" }} onClick={sellGems} disabled={!account || !chainOk}>
            Sell Gems
          </button>

          <hr style={hr} />

          <div style={label}>Battle (cooldown 24h)</div>

          <div style={{ display: "flex", gap: 8, alignItems: "center", marginBottom: 8 }}>
            <div style={{ fontSize: 13, opacity: 0.8 }}>
              {kingdom
                ? battleReady
                  ? "✅ Ready"
                  : `⏳ Cooldown: ${formatDuration(battleRemaining)}`
                : "—"}
            </div>
          </div>

          <div style={label}>Win chance (40..60)</div>
          <input
            style={input}
            value={winChance}
            onChange={(e) => setWinChance(e.target.value)}
            placeholder="50"
          />

          <button
            style={{ ...btn, background: "#ef4444" }}
            onClick={doBattle}
            disabled={!account || !chainOk || !kingdom || battleRemaining > 0 || kingdom.perHour <= 0}
          >
            Battle
          </button>

          <div style={{ fontSize: 12, opacity: 0.7, marginTop: 10 }}>
            Règles: winChance 40..60, cooldown 24h, perHour > 0.
          </div>

          <hr style={hr} />

          <div style={label}>Mode</div>
          <div style={{ display: "flex", gap: 8, marginBottom: 12 }}>
            <button
              style={{
                ...pill,
                background: mode === "build" ? "#16a34a" : "#f3f4f6",
                color: mode === "build" ? "white" : "#111827"
              }}
              onClick={() => {
                setMode("build");
                setSelectedUpgradeTile(null);
              }}
            >
              Place buildings
            </button>
            <button
              style={{
                ...pill,
                background: mode === "upgrade" ? "#16a34a" : "#f3f4f6",
                color: mode === "upgrade" ? "white" : "#111827"
              }}
              onClick={() => {
                setMode("upgrade");
                setSelectedBuildTiles(new Set());
              }}
            >
              Upgrade building
            </button>
          </div>

          {mode === "build" ? (
            <>
              <div style={label}>Niveau à placer (1..8)</div>
              <select
                style={{ ...input, marginBottom: 10 }}
                value={buildLevel}
                onChange={(e) => setBuildLevel(Number(e.target.value))}
              >
                {[1, 2, 3, 4, 5, 6, 7, 8].map((l) => (
                  <option key={l} value={l}>
                    Level {l}
                  </option>
                ))}
              </select>

              <div style={{ fontSize: 13, opacity: 0.8, marginBottom: 8 }}>
                Sélection: <b>{buildCount}</b> case(s) vide(s)
              </div>
              <div style={{ fontSize: 13, opacity: 0.8, marginBottom: 12 }}>
                Estimations: <b>cost</b> {estBuildCost?.toLocaleString() ?? "—"} gold,{" "}
                <b>+perHour</b> {estBuildPerHour?.toLocaleString() ?? "—"}
              </div>

              <button
                style={{ ...btn, background: "#f59e0b" }}
                onClick={placeBuildings}
                disabled={!account || !chainOk || buildCount < 1}
              >
                Place Buildings
              </button>

              <div style={{ fontSize: 12, opacity: 0.7, marginTop: 10 }}>
                Règles: cases vides, level 1..8, gold suffisant.
              </div>
            </>
          ) : (
            <>
              <div style={{ fontSize: 13, opacity: 0.8, marginBottom: 8 }}>
                Case sélectionnée: <b>{selectedUpgradeTile ?? "—"}</b>
              </div>

              {upgradeTileInfo && selectedUpgradeTile !== null && (
                <div style={{ fontSize: 13, opacity: 0.85, marginBottom: 12 }}>
                  Level <b>{upgradeTileInfo.level}</b> — upgrades <b>{upgradeTileInfo.upgrades}</b> (raw: {upgradeTileInfo.raw})
                  <div style={{ marginTop: 6 }}>
                    Estimations: <b>cost</b> {estUpgradeCost?.toLocaleString() ?? "—"} gold,{" "}
                    <b>+perHour</b> {estUpgradePerHour?.toLocaleString() ?? "—"}
                  </div>
                </div>
              )}

              <button
                style={{ ...btn, background: "#a855f7" }}
                onClick={upgradeBuilding}
                disabled={!account || !chainOk || selectedUpgradeTile === null}
              >
                Upgrade Building
              </button>

              <div style={{ fontSize: 12, opacity: 0.7, marginTop: 10 }}>
                Règles: case non vide, upgrades < 9, gold suffisant.
              </div>
            </>
          )}

          {(status || err) && (
            <div style={{ marginTop: 14 }}>
              {status && <div style={{ padding: 10, borderRadius: 12, background: "#f3f4f6" }}>{status}</div>}
              {err && (
                <pre
                  style={{
                    marginTop: 10,
                    padding: 10,
                    borderRadius: 12,
                    background: "#fff1f2",
                    color: "#9f1239",
                    whiteSpace: "pre-wrap",
                    fontSize: 13
                  }}
                >
                  {err}
                </pre>
              )}
            </div>
          )}
        </section>

        {/* RIGHT - Kingdom + Grid */}
        <section style={card}>
          <h2 style={h2}>Kingdom</h2>

          {!account && <div style={{ opacity: 0.7 }}>Connecte ton wallet pour charger ton Kingdom.</div>}

          {kingdom && (
            <>
              <div style={{ display: "grid", gridTemplateColumns: "repeat(3, minmax(0, 1fr))", gap: 10 }}>
                <Stat k="Gold" v={kingdom.gold.toLocaleString()} />
                <Stat k="Gems" v={kingdom.gems.toLocaleString()} />
                <Stat k="Per hour" v={kingdom.perHour.toLocaleString()} />
                <Stat k="Allies" v={kingdom.alliesCount} />
                <Stat k="Allies earned" v={kingdom.alliesEarned} />
                <Stat k="Ally" v={shortAddr(kingdom.ally)} />
              </div>

              <hr style={hr} />

              <div style={{ display: "flex", justifyContent: "space-between", gap: 10, alignItems: "end", marginBottom: 10 }}>
                <div>
                  <div style={{ fontSize: 13, opacity: 0.7 }}>
                    Tiles (360) — clique pour {mode === "build" ? "sélectionner cases vides" : "choisir case à upgrader"}
                  </div>
                  <div style={{ fontSize: 12, opacity: 0.6, marginTop: 4 }}>
                    0 = vide | sinon raw = upgrades×10 + level (level = raw % 10)
                  </div>
                </div>
                {mode === "build" && (
                  <button
                    style={{ ...pill, background: "#111827", color: "white" }}
                    onClick={() => setSelectedBuildTiles(new Set())}
                  >
                    Clear
                  </button>
                )}
              </div>

              {grid && (
                <div style={{ display: "grid", gap: 6 }}>
                  {grid.map((row, r) => (
                    <div key={r} style={{ display: "flex", gap: 4 }}>
                      {row.map((raw, c) => {
                        const tileId = r * 20 + c;
                        const info = decodeTile(raw);

                        const isBuildSelected = selectedBuildTiles.has(tileId);
                        const isUpgradeSelected = selectedUpgradeTile === tileId;

                        const bg = info.empty ? "#0b1220" : tileBg(info.level);
                        const outline =
                          mode === "build"
                            ? isBuildSelected
                              ? "2px solid #f59e0b"
                              : "1px solid rgba(255,255,255,0.10)"
                            : isUpgradeSelected
                            ? "2px solid #a855f7"
                            : "1px solid rgba(255,255,255,0.10)";

                        const canClick =
                          mode === "build"
                            ? info.empty
                            : !info.empty && info.upgrades < 9 && info.level >= 1 && info.level <= 8;

                        return (
                          <div
                            key={c}
                            onClick={() => canClick && onTileClick(tileId)}
                            title={`tile ${tileId} — raw ${info.raw} — level ${info.level} — upgrades ${info.upgrades}`}
                            style={{
                              background: bg,
                              border: outline,
                              borderRadius: 7,
                              width: 18,
                              height: 18,
                              display: "grid",
                              placeItems: "center",
                              fontSize: 10,
                              color: info.level >= 8 ? "#111827" : "rgba(255,255,255,0.85)",
                              userSelect: "none",
                              cursor: canClick ? "pointer" : "default",
                              opacity: canClick ? 1 : 0.55
                            }}
                          >
                            {info.empty ? "" : `${info.level}${info.upgrades ? `+${info.upgrades}` : ""}`}
                          </div>
                        );
                      })}
                    </div>
                  ))}
                </div>
              )}
            </>
          )}
        </section>
      </div>

      <footer style={{ opacity: 0.7, fontSize: 12, marginTop: 16 }}>
        PlaceBuildings / UpgradeBuilding issus du code vérifié du contrat BNBKing.
      </footer>
    </div>
  );
}

function Stat({ k, v }: { k: string; v: string | number }) {
  return (
    <div style={{ padding: 10, border: "1px solid #e5e7eb", borderRadius: 14 }}>
      <div style={{ fontSize: 12, opacity: 0.7 }}>{k}</div>
      <div style={{ fontSize: 18, fontWeight: 750, marginTop: 4 }}>{v ?? "—"}</div>
    </div>
  );
}

const card = {
  border: "1px solid #e5e7eb",
  borderRadius: 18,
  padding: 16,
  boxShadow: "0 1px 10px rgba(0,0,0,0.05)",
  background: "white"
};

const h2 = { margin: "0 0 12px 0", fontSize: 16 };

const btn = {
  padding: "10px 12px",
  borderRadius: 14,
  border: "1px solid #e5e7eb",
  background: "#16a34a",
  color: "white",
  fontWeight: 700,
  cursor: "pointer"
};

const pill = {
  padding: "8px 10px",
  borderRadius: 999,
  border: "1px solid #e5e7eb",
  cursor: "pointer",
  fontWeight: 700
};

const input = {
  width: "100%",
  padding: "10px 12px",
  borderRadius: 14,
  border: "1px solid #e5e7eb",
  marginTop: 6,
  marginBottom: 8
};

const label = { fontSize: 12, opacity: 0.7, marginBottom: 6 };
const hr = { border: 0, borderTop: "1px solid #e5e7eb", margin: "14px 0" };
